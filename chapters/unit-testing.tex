\chapter{Unit Testing Framework}
\label{chapter:unit-testing-framework}

\section{Terms and Definitions}

\emph{Unit testing} is the process of verifying that written code produces expected results when given specific inputs. \emph{Unit under test} is a common term that refers to the specific part of the code that is being tested by a specific \emph{test case}. Unit testing is often powered by a \emph{unit testing framework} which is a set of tools dedicated to simplify writing and running unit tests.

One notable property of a typical unit test is that it deals with the smallest logical piece of code possible: one particular function or a single method of a class. Consequently, distinct unit tests are ususally independent of each other and can be run in any order or in parallel. This is a desirable feature of a good unit testing framework.

However, there are also cases when the complexity of a unit test is higher. For example, when a class heavily relies on data coming from a database, a unit test needs to \emph{mock} the database connection and the data. \emph{Mocking} is the process of simulating a real object with a simplified and predictable version of it.

It is often the case that many unit tests share the same logic. When testing hash functions, this logic could be summarized with the following steps:

\begin{enumerate}
    \item Select a configuration of the hash function.
    \item Provide input data: a password, a salt, etc.
    \item Compute the hash value and compare it to the correct one.
   \end{enumerate}

Clearly, manually writing a unit test for each combination of the hash function configuration and each set of input parameters is a daunting task. \emph{Parametrized unit testing} allows to generate a template for a large number of unit tests and is therefore a desirable feature of a testing frameworks.

\emph{Code coverage} is an indicator that provides better understanding of how well a program is being tested. If only a small portion of the program gets executed, then code coverage tends to be low. There are many ways to measure code coverage but probably the most common one is to count the number of source code lines that were executed by a test suite and return it as a percentage of the total number of lines.

Other types of coverage include: \emph{function} and \emph{statement} coverage (i.e. the portion of functions or statements that has been executed), \emph{branch} and \emph{condition} coverage (i.e. the portion of conditions/branches executed in relation to the total number of \emph{all possible} combinations) and many others. However, in practice \emph{line coverage} is the more common indicator.

\emph{Continuous integration} is the practice of running unit tests (and measuring code coverage changes) with every codebase change. This approach helps identify problems early and fix them quicker. It often comes in the form of a dedicated machine that builds and runs the tests each time a change is pushed to the source code repository.

\section{Choice of the Unit Testing Framework}

Although the reference reference Lyra2 project in \cite{github:2017:lyra} has automated tests, it does not use a dedicated unit testing framework. This is a reasonable choice which has its advantages. To start with, it allows to keep the complexity of the project low and not rely on external libraries. The build process is somewhat simplified as well.

Secondly, when it comes to the \texttt{C/C++} ecosystem, the choice of the framework is not trivial. The authors of Argon2 have also faced this choice and opted out to write their own test harness in \cite{github:2017:argon2-test.c}. Section \ref{sec:unit-boost-google} will try to explain why. Section \ref{sec:unit-junit-testng} will provide motivation for my choice of the unit testing framework for the Java port and section \ref{sec:unit-pytest} will describe the test suite for the Python 3 harness.

\subsection{Boost.Test}
\label{sec:unit-boost-google}

Admittedly, there is a wide choice of unit testing frameworks for the \texttt{C/C++} ecosystem. An extensive list can be found in \cite{wiki:2017:frameworks-c, wiki:2017:frameworks-cpp}. Given the number of available solutions, their comparison and an educated choice would be a large and daunting task for any developer. This could be one of the reasons why project authors sometimes tend to avoid actually using a unit testing framework. Instead, it is far more simple to write a separate test file that would run a few sanity checks.

Consider the case of Argon2. As one can see in \cite{github:2017:argon2}, the in-house \texttt{src/test.c} test harness for Argon2 was introduced on 25\textsuperscript{th} of January 2016. The commit hash starts with \texttt{7450df88} and it is number 317 out of (current) almost 600 in the version control history. It is safe to say that this testing was introduced at the later stages of the project when the need for it was apparent \footnote{https://github.com/P-H-C/phc-winner-argon2/issues/85}.

A similar story could be observed for the reference Lyra2 project \cite{github:2017:lyra}. The rest of this section will attempt to answer the question why a rather popular unit-testing library \textsc{Boost.Test} is not the best fit for the password hashing projects. The main features of the library are summarized in table \ref{table:framework-features-cpp}.

\textsc{Boost} is a large collection of different libraries for \texttt{C++}. It was originally founded by Beman Dawes and David Abrahams but today the number of contributors is in the hundreds. The scope of the libraries spans from concurrent programming to regular expressions to linear algebra. There is a formal submission process \footnote{http://www.boost.org/development/submissions.html} for any library that would like to be included into the collection as well as rigorous review in the mailing lists \footnote{http://www.boost.org/community/groups.html\#main}. Many of the ideas that originate in \textsc{Boost} are later adopted by the \texttt{C++} language standard.

The \textsc{Boost.Test} is a well-designed and thought through unit-testing framework. It is licensed under the Boost Software License which is a free software license, OSI-approved and compatible with GPL. The library supports both parametrized tests as well as parallel execution.

\begin{table}
\begin{center}
\begin{tabular}{llll}
    Name & License & Parametrization & Parallelism \\ \hline
\textsc{Boost.Test} & Boost Software License & yes & needs 3\textsuperscript{rd} party runner
% Google Test & MIT & parameters? & yes
\end{tabular}
\end{center}
\caption{Main features of \textsc{Boost.Test}, adapted from \cite{wiki:2017:frameworks-cpp}}
\label{table:framework-features-cpp}
\end{table}

\subsection{JUnit and TestNG}
\label{sec:unit-junit-testng}
\subsection{Unit Testing with py.test}
\label{sec:unit-pytest}
