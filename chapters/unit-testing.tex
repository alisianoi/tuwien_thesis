\chapter{Unit Testing Framework}
\label{chapter:unit-testing-framework}

\section{Terms and Definitions}

\emph{Unit testing} is the process of verifying that written code produces expected results when given specific inputs. \emph{Unit under test} is a common term that refers to the specific part of the code that is being tested by a specific \emph{test case}. Unit testing is often powered by a \emph{unit testing framework} which is a set of tools dedicated to simplify writing and running unit tests.

One notable property of a typical unit test is that it deals with the smallest logical piece of code possible: one particular function or a single method of a class. Consequently, distinct unit tests are ususally independent of each other and can be run in any order or in parallel. This is a desirable feature of a good unit testing framework.

However, there are also cases when the complexity of a unit test is higher. For example, when a class heavily relies on data coming from a database, a unit test needs to \emph{mock} the database connection and the data. \emph{Mocking} is the process of simulating a real object with a simplified and predictable version of it.

It is often the case that many unit tests share the same logic. When testing hash functions, this logic could be summarized with the following steps:

\begin{enumerate}
    \item Select a configuration of the hash function.
    \item Provide input data: a password, a salt, etc.
    \item Compute the hash value and compare it to the correct one.
   \end{enumerate}

Clearly, manually writing a unit test for each combination of the hash function configuration and each set of input parameters is a daunting task. \emph{Parametrized unit testing} allows to generate a template for a large number of unit tests and is therefore a desirable feature of a testing frameworks.

\emph{Code coverage} is an indicator that provides better understanding of how well a program is being tested. If only a small portion of the program gets executed, then code coverage tends to be low. There are many ways to measure code coverage but probably the most common one is to count the number of source code lines that were executed by a test suite and return it as a percentage of the total number of lines.

Other types of coverage include: \emph{function} and \emph{statement} coverage (i.e. the portion of functions or statements that has been executed), \emph{branch} and \emph{condition} coverage (i.e. the portion of conditions/branches executed in relation to the total number of \emph{all possible} combinations) and many others. However, in practice \emph{line coverage} is the more common indicator.

\emph{Continuous integration} is the practice of running unit tests (and measuring code coverage changes) with every codebase change. This approach helps identify problems early and fix them quicker. It often comes in the form of a dedicated machine that builds and runs the tests each time a change is pushed to the source code repository.

\section{Choice of the Unit Testing Framework}

Although the reference reference Lyra2 project in \cite{github:2017:lyra} has automated tests, it does not use a dedicated unit testing framework. This is a reasonable choice which has its advantages. To start with, it allows to keep the complexity of the project low and not rely on external libraries. The build process is somewhat simplified as well.

Secondly, when it comes to the \texttt{C/C++} ecosystem, the choice of the framework is not trivial. The authors of Argon2 have also faced this choice and opted out to write their own test harness in \cite{github:2017:argon2-test.c}. Section \ref{sec:unit-boost-google} will try to explain why. Section \ref{sec:unit-junit-testng} will provide motivation for my choice of the unit testing framework for the Java port and section \ref{sec:unit-pytest} will describe the test suite for the Python 3 harness.

\subsection{Boost.Test and Google Test}
\label{sec:unit-boost-google}
\subsection{JUnit and TestNG}
\label{sec:unit-junit-testng}
\subsection{Unit Testing with py.test}
\label{sec:unit-pytest}
