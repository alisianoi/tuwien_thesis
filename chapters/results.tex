%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results}
\label{sec:results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Algorithm-level compatibility}

The primary goal of this work was to port Lyra2 to Java so that it would produce the same hash values as the reference implementation when given the same inputs. Such algorithm-level compatibility was achieved and will be demonstrated in section \ref{sec:manual-testing} and section \ref{sec:automated-testing}. The former deals with hand-picked test vectors while the latter demonstrates a reasonably large collection of randomly picked test vectors and a unit-testing framework them to verify hash results.

\subsection{Configuration choice}
By design Lyra2 has a large number of configurable parameters. This section will provide rationale for choosing particular values. The short summary can be found in table \ref{table:configuration-summary}.

There are three sponges that could be tested: Blake2b, BlaMka and half-round BlaMka. Just the first two are in the manual testing shortlist because half-round BlaMka is similar to BlaMka. The sponge block size can be either 8, 10 or 12, so the extreme values made it into the shortlist. The columns of the memory matrix can be any positive number. The \path{Lyra2/src/runBenchCPU.sh} benchmarking script as well as other sources suggest that the values of 256 and 512 should be chosen.

Finally, time and memory costs are fixed at an arbitrary value of 100. The output length is chosen to be 10 so that the resulting hash value would fit easily on the page.

\begin{table}
\begin{center}
\begin{tabular}{l r}
Parameter & Value \\ \hline
Sponge & Blake2b, BlaMka \\
Sponge blocks & 8, 12 \\
Columns in the memory matrix & 256, 512 \\
Time cost (number of iterations) & 100 \\
Memory cost (number of rows in the memory matrix) & 100 \\
Output length (bytes) & 10 \\
\end{tabular}
\end{center}
\caption{Summary of parameter values for tested configurations}
\label{table:configuration-summary}
\end{table}

\subsection{Manual testing}
\label{sec:manual-testing}

Below is a log of manual tests. New line delimits different Lyra2 configurations. The first line of each group represents a particular configuration group: \verb|--outlen| is the output length, \verb|--tcost| is the time cost, \verb|--mcost| is memory cost. The second and the forth line in each group is the password and salt pair, and the third and fifth lines are the resulting hash values.

\tiny
\begin{verbatim}
$ lyra2 --sponge blake2b --blocks 8 --columns 256 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> 19 FD 3B 50 9A 03 0C DF 95 DA
> "The quick brown fox jumped over the lazy dog" "0123456789"
> 04 A0 BF 30 D1 E5 A5 05 53 E9

$ lyra2 --sponge blake2b --blocks 8 --columns 512 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> 73 39 79 B6 C1 3C C1 F3 D7 17
> "The quick brown fox jumped over the lazy dog" "0123456789"
> A1 B0 18 F6 B6 79 5F E0 2A A4

$ lyra2 --sponge blake2b --blocks 12 --columns 256 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> 9C 52 2A B9 18 30 F9 E7 09 55
> "The quick brown fox jumped over the lazy dog" "0123456789"
> 7D B2 9D C8 31 B4 E9 0E 10 22

$ lyra2 --sponge blake2b --blocks 12 --columns 512 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> AC F2 B6 50 2D BC F0 62 DD 29
> "The quick brown fox jumped over the lazy dog" "0123456789"
> 4F 1B 03 6B C9 A2 09 C4 BC DA

$ lyra2 --sponge blamka --blocks 8 --columns 256 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> 53 32 F3 D7 C4 9C 46 38 3C 1B
> "The quick brown fox jumped over the lazy dog" "0123456789"
> E7 6E 4B A0 81 B8 3C CF D6 64

$ lyra2 --sponge blamka --blocks 8 --columns 512 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> D9 F9 F5 65 0D 05 88 D0 DF F6
> "The quick brown fox jumped over the lazy dog" "0123456789"
> 3A 3D 40 00 3E 33 44 45 B3 DD

$ lyra2 --sponge blamka --blocks 12 --columns 256 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> C1 BC 48 80 99 1C E7 E6 52 18
> "The quick brown fox jumped over the lazy dog" "0123456789"
> 2E 4E 56 C7 5B 3D B7 F9 E0 30

$ lyra2 --sponge blamka --blocks 12 --columns 512 --outlen 10 --tcost 100 --mcost 100
> "password" "salt"
> 82 AF EB 03 5B E7 12 11 BE 63
> "The quick brown fox jumped over the lazy dog" "0123456789"
> F7 A8 56 D5 81 16 AA E5 C7 4D
\end{verbatim}
\normalsize

\subsection{Automated testing}
\label{sec:automated-testing}

The automated testing is possible because of the additional code that was added to the reference implementation. As mentioned in section \ref{sec:reference-implementation}, there is a \verb|harness| branch which could be found in the forked GitHub project \cite{github:2017:lyra-copy} and the corresponding pull request \cite{github:2017:lyra-pr}. This branch introduces the \verb|Lyra2/tests/harness.py| script written in Python 3 which allows to compile several configurations of Lyra2 and then use those to compute and store hash values.

Additionally, the \verb|Lyra2/tests/take.py| Python 3 script was used to choose a number of random hash values from those previously precomputed. These were then used in the Java project to unit-test the implementation. They were also included into the continuous integration service and their status can be verified by following \cite{travis:2017:lyra}. In conclusion, both manual and automated testing indicate that the ported implementation does not contain immediately visible problems.

\section{Performance comparison}

The single-threaded configuration of the reference C implementation was compared to the ported Java implementation. For that, a separate GitHub repository 

\subsection{Project structure}

To perform comparison of the original C implementation and its ported Java version, a separate project was created and is hosted in \href{https://github.com/all3fox/lyra2-compare}{a public GitHub repository}. At the core of this project lies the open-source \href{https://jupyter.org/}{Jupyter Notebook} which simplifies reproduction of comparison results.

The following producer-consumer strategy is employed. The producer is the \texttt{./src/compare.ipynb} script which is responsible for compiling both C and Java implementations as well as dispatching computation tasks. The results are then collected into the \texttt{measurements.db} SQLite database (which also serves as a cache layer). The consumer is the \texttt{./src/plot.ipynb} script which reads the data from the SQLite database and plots the figures shown below.

Conceptually, Lyra2 provides two main adjustable parameters: time and memory cost. This is why this performance comparison includes sections where one of these parameters is fixed and the other is changed. This is done for several Lyra2 configurations and their running time as well as memory consumption is compared. For the exact comparison steps you could consult \href{https://github.com/all3fox/lyra2-compare/blob/master/src/compare.ipynb}{the script} but here is a quick summary:

\begin{itemize}
\item Separate configurations are run in parallel, creating one process per configuration.
\item Running time is measured as the time between the creation of the process and its termination.
\item Memory consumption of the created process is measured externally and the peak value is recorded.
\end{itemize}

There is also a section where both time and memory costs are changed at the same time. This produces 3-dimensional plots. Direct comparison of such plots is difficult but they still provide a good feel for how the running time and memory consumption are changing.

\subsection{Fixed time cost}

There are two figures that show how running time and consumed memory depend on memory cost when the time cost is fixed. Figure \ref{figure:mcost_256} shows a 256-column and figure \ref{figure:mcost_2048} shows a 2048-column configuration of Lyra2. Both these figures clearly show that the original C implementation works faster and consumes less memory than its Java counterpart. A nice property is that both the running time and memory consumption are changing roughly linearly as the memory cost parameter is changed. This is consistent with the fact that the memory cost parameter corresponds to the number of rows of the in-memory matrix.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/mcost_256}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: 256 columns, fixed time cost of 10}
    \label{figure:mcost_256}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/mcost_2048}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: 2048 columns, fixed time cost of 10}
    \label{figure:mcost_2048}
\end{figure}

\subsection{Fixed memory cost}

There are two figures that show how running time and consumed memory depend on time cost when the memory cost is fixed. Figure \ref{figure:tcost_256} shows a 256-column and figure \ref{figure:tcost_2048} shows a 2048-column configuration of Lyra2. Both these figures clearly show that the original C implementation works faster and consumes less memory than its Java counterpart.
The running time changes roughly linearly as the time cost parameter is changed which is consistent with the fact that time cost corresponds to the number of iterations done by Lyra2. Memory consumption stays roughly the same which is also consistent with the fact that the largest memory consumer is the in-memory matrix. This matrix has the same size for all of the configurations.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/tcost_256}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: 256 columns, fixed memory cost of 20}
    \label{figure:tcost_256}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/tcost_2048}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: 2048 columns, fixed memory cost of 20}
    \label{figure:tcost_2048}
\end{figure}

\subsection{Changing time and memory costs}

There are four figures that show running time and memory consumption of Lyra2 when both time and memory costs change. Figures \ref{figure:tcost_mcost_blake2b_256} and \ref{figure:tcost_mcost_blake2b_2048} correspond to a 256- and 2048-column configurations of Lyra2 that both use the Blake2b sponge. Figures \ref{figure:tcost_mcost_blamka_256} and \ref{figure:tcost_mcost_blamka_2048} are the 256- and 2048-column configurations of Lyra2 with the BlaMka sponge. All of these four figures share the same properties. First of all, the original C implementation is still faster and consumes less memory than the Java one. Secondly, the running time as well as required space depend roughly linearly on the time and memory cost parameters simultaneously. The second observation goes somewhat against my intuition: my expectations where to see quadratic dependency since both the size of the matrix and the number of iterations are increased at the same time.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/tcost_mcost_blake2b_256}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: Blake2b sponge, 256 columns.}
    \label{figure:tcost_mcost_blake2b_256}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/tcost_mcost_blake2b_2048}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: Blake2b sponge, 2048 columns.}
    \label{figure:tcost_mcost_blake2b_2048}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/tcost_mcost_blamka_256}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: BlaMka sponge, 256 columns. }
    \label{figure:tcost_mcost_blamka_256}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{figures/tcost_mcost_blamka_2048}
    \caption{\texttt{lyra2-c} compared to \texttt{lyra2-java}: BlaMka sponge, 2048 columns.}
    \label{figure:tcost_mcost_blamka_2048}
\end{figure}

\subsection{Comparison Conclusion}

Even though Java version is outperformed by the original C implementation, it should be taken into account that there are a lot of extra steps on the Java side that are required to achieve byte-level compatibility. Finally, the measurements were collected across several days of computation on a personal machine which explains a couple outliers present in the figures.

\subsubsection{Endianness}
To start with, the C implementation uses \texttt{memcpy} which relies on the endianness of the underlying system (little-endian for the \texttt{x86-64} architecture). At the same time, the Java Virtual Machine stores its bytes in network order (big-endian). At the heart of Lyra2 is a memory matrix that is constantly written to and read from. So, the Java version suffers a performance penalty (nearly) each time because the byte-order has to be explicitly accounter for.

\subsubsection{Unsigned integers}
The C language supports both signed and unsigned (fixed) width integers. The Java specification provides unsigned integers starting with the 8th version of the language as a separate class and not a primitive, which also contributes to the overhead. Finally, there is also a difference between \texttt{Math.floorMod} and \texttt{\%} in Java with regards to the signs of the arguments and results. Using a library function instead of something built-in also contributes to the overhead.
