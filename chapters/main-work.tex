%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Details of the Ported Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

One of the immediate issues that needs to be addressed is the class/inheritance structure of the project. The reference implementation is written in C and relies heavily on functions and conditional compilation. This presents a difficulty conditionally compiled functions do not directly translate to a clean class hierarchy. Furthermore, it is borderline impossible to design an architecture and not have to change it later on. Figure \ref{fig:uml} in part shows the final architecture of the Java project.

The \texttt{Main} class is the usual entry point of the project. An implementational detail that is not shown in figure \ref{fig:uml} is that the \texttt{Main} class relies on a 3\textsuperscript{rd} party command line library that parses input parameters (like the password, the salt and a few others) and constructs an instance of \texttt{LyraParams} class. That class is also not shown in the figure, it simply stores a number of parametrs and constants relevant to Lyra2's operation. Finally, the \texttt{echo} class is a collection of methods for pretty-printing different types of arrays as a table of bytes to the console.

The \texttt{mem} and \texttt{pack} classes are responsible for certain memory manipulations. In particular, the \texttt{mem} class deals with the little- and big-endian discrepancies between the C and Java ecosystems on the \texttt{x86\_64} architecture. At the same time the \texttt{pack} class provides methods that allow to emulate the recasting of the \texttt{void*} pointer to other kinds of pointers (for instance, the \texttt{uint64\_t*} or the \texttt{char*} pointers).

The \texttt{Lyra2} class contains the main logic of the single-threaded Lyra2 PHS. The functionality related to the sponge construction is collected in the \texttt{Sponge} \emph{abstract} class and its subclasses \texttt{SpongeBlake2b}, \texttt{SpongeBlamka} and \texttt{SpongeHalfBlamka} capture the specifics of the fixed-width permutation \(f\).

An insteresting detail is that the Sponge class in the Java project makes use of both left- and right bit rotations, done by the \texttt{rotl64} and \texttt{rotr64} methods respectively. This is despite the fact that the original Lyra2 reference implementation requires just one direction for rotations. Both types of rotations are helpful in the Java project because they allow to avoid a number of bit rotations related to endianness. For example see figure \ref{fig:sponge-blake2b}, lines \(5, 8\), and \(11\) do not call \texttt{mem.flip} while line \(16\) cannot use the same trick and has to perform a right-rotation and endianness conversions.

\begin{figure}
\begin{tikzpicture}
    \begin{umlpackage}{lyra2}
        \umlclass{Main}{}{
            \umlstatic{
                + main(argv: String[]): void
            }
        }

        \umlclass[right=1cm of Main]{mem}{}{
            \umlstatic{
                + copy(dst: byte[], offset: int, src: int): void
            } \\
            \umlstatic{
                + flip(x: long): long
            }
        }

        \umlclass[below=0.5cm of Main]{echo}{}{
            \umlstatic{
                + bytes(bytes: byte[], n: int, m: int, s: int): void
            } \\
            \umlstatic{
                + bytes(bytes: byte[], n: int): void
            } \\
            \umlstatic{
                + bytes(longs: long[], n: int, m: int, s: int): void
            } \\
            \umlstatic{
                + bytes(longs: long[], n: int): void
            } \\
            \umlstatic{
                + params(params: LyraParams): void
            }
        }

        \umlclass[right=1cm of echo]{pack}{}{
            \umlstatic{
                + bytes(x: long): byte[]
            } \\
            \umlstatic{
                + bytes(longs: long[]): byte[]
            } \\
            \umlstatic{
                + longs(bytes: byte[]): longs[]
            } \\
            \umlstatic{
                + bytes(strings: String[]): byte[]
            }
        }


        \umlclass[below right=0.5cm and -6cm of echo]{Lyra2}{}
        {
            \umlstatic{
                + phs(hash: byte[], pass: byte[], salt: byte[], params: LyraParams): void
            } \\
            \umlstatic{
                + hash(hash: byte[], pass: byte[], salt: byte[], params: LyraParams): void
            }
        }

        \umlclass[below=0.5cm of Lyra2]{Sponge}{
            + state: long[]
        }{
            + absorb(src: long[], len: int, offset: int): void \\
            + squeeze(dst: byte[], len: int): void \\
            + sponge\_lyra(rounds: int): void \\
            \umlstatic{
                + rotr64(word: long, b: int): void
            } \\
            \umlstatic{
                + rotl64(word: long, b: int): void
            } \\
            \umlvirt{
                + G(a: int, b: int, c: int, d: int): void
            } \\
            + reduced\_squeeze\_row0(dst: long[], offset: int): void \\
            + reduced\_duplex\_row1\_and\_row2(dst: long[], offset1: int, offset2: int): void \\
            + reduced\_duplex\_row\_filling(dst: long[], offset0: int, offset1: int, offset2: int, offset3: int): void \\
            + reduced\_duplex\_row\_wandering(dst: long[], offset0: int, offset1: int, offset2: int, offset3: int): void
        }

        \umlclass[below left=0.5cm and -6cm of Sponge]{SpongeBlake2b}{}{
            + G(a: int, b: int, c: int, d: int): void
        }

        \umlclass[below left=0.5cm and -15cm of Sponge]{SpongeBlamka}{}{
            + G(a: int, b: int, c: int, d: int): void
        }

        \umlclass[below=3cm of Sponge]{SpongeHalfBlamka}{}{
            + G(a: int, b: int, c: int, d: int): void
        }

        \umlHVinherit{SpongeBlake2b}{Sponge}
        \umlHVinherit{SpongeBlamka}{Sponge}
        \umlHVinherit{SpongeHalfBlamka}{Sponge}
      \end{umlpackage}
  \end{tikzpicture}
  \caption{Approximate class diagram for \texttt{com.github.all3fox.lyra2} package}
  \label{fig:uml}
  \end{figure}

% \begin{figure}
% \small
% \begin{minted}{java}
% public abstract class Sponge {
%     public long[] state;
%
%     public void absorb(long[] src, int len, int offset) {
%         /* default implementation */
%     }
%
%     public void squeeze(byte[] dst, int len) {
%         /* default implementation */
%     }
%
%     public abstract void G(int a, int b, int c, int d);
%
%     public void permute_state(int rounds) {
%         for (int round = 0; round != rounds; ++round) {
%             /* call G to permute the state of the sponge */
%         }
%     }
%
%     public void reduced_squeeze_row0(long[] dst, int offset) {
%         /* custom squeeze, reduced number of rounds */
%     }
%
%     public void reduced_duplex_row1_and_row2(
%         long[] dst, int offset1, int offset2
%     ) {
%         /* custom absorb + squeeze, reduced number of rounds */
%     }
%
%     public void reduced_duplex_row_filling(
%         long dst[], int offset0, int offset1, int offset2, int offset3
%     ) {
%         /* custom absorb + squeeze, reduced number of rounds */
%     }
%
%     public void reduced_duplex_row_wandering(
%         long[] dst, int offset0, int offset1, int offset2, int offset3
%     ) {
%         /* custom absorb + squeeze, reduced number of rounds */
%     }
% }
% \end{minted}
% \normalsize
% \caption{Outline of the abstract Sponge class}
% \label{fig:sponge}
% \end{figure}

\begin{figure}
\small
\begin{minted}[linenos]{java}
    public class SpongeBlake2b extends Sponge {
        @Override
        public void G(final int a, final int b, final int c, final int d) {
            state[a] = mem.flip(mem.flip(state[a]) + mem.flip(state[b]));
            state[d] = rotl64(state[d] ^ state[a], 32);

            state[c] = mem.flip(mem.flip(state[c]) + mem.flip(state[d]));
            state[b] = rotl64(state[b] ^ state[c], 24);

            state[a] = mem.flip(mem.flip(state[a]) + mem.flip(state[b]));
            state[d] = rotl64(state[d] ^ state[a], 16);

            state[c] = mem.flip(mem.flip(state[c]) + mem.flip(state[d]));
            // Cannot use the left rotation trick here: 63 % 8 != 0, so
            // individual bytes do not stay the same, they change too.
            state[b] = mem.flip(rotr64(mem.flip(state[b] ^ state[c]), 63));
        }
    }
\end{minted}
\normalsize
\caption{Blake2b as instance of the Sponge class, illustrating optimized rotations}
\label{fig:sponge-blake2b}
\end{figure}
