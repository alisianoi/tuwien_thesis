\chapter{Related Work}
\label{chapter:related-work}

\section{Cryptographic Competitions}

It is common practice to announce a competition in order to develop standard cryptographic primitives. For example, the symmetric block cipher Rijndael \cite{daemen:2002:DRA} was chosen to become the Advanced Encryption Standard (AES) \cite{aes-fips} in a competitive selection process that lasted from 1997 to 2000. The competition was organized by the National Institute of Standards and Technology (NIST) and included 15 different designs which were narrowed down to 5 during the final phase: Rijndael, Serpent, Twofish, RC6 and MARS. Such an open standartization process was highly praised by the cryptographic community. So, another competition was held by NIST between 2007 and 2012 in order to select the next hash function standard, SHA-3. The final round included 5 designs: BLAKE, Gr√∏stl, JH, Sklein and Keccak, the last of which ultimately became the winner of the competition.

Choosing cryptographic primitives through an open competitive process is an effective approach. Therefore, when the need for an updated, memory-hard password hashing scheme became apparent, a Password Hashing Competition was held. This time, however, it was not organized by NIST but directly by the cryptographic community. In particular, the \url{password-hashing.net} website lists two well-known cryptographers Dmitry Khovratovich and Jean-Philippe Aumasson as direct contacts. The Password Hashing Competition concluded in 2015, with Argon2 selected as its winner and Catena, Lyra2, Makwa and yescrypt receiving special recognition.

\section{Password Hashing Fundamentals}
\label{sec:fundamentals}

\emph{Password hashing} is the process of transforming a password into a hash value. Given the resulting hash value it should be computationally infeasible to restore the original password.

Password hashing is common practice when user authentication is required. The user provides a password which is then hashed using some password hashing algorithm. The resulting hash is then compared against a hash value which is stored in the database and is known to be correct. If both hashes match, the user is authenticated.

When a password database is leaked, the password hashing process is what prevents the attackers from gaining the original plaintext passwords. One of the early password hashing schemes, which is widely used today, is PBKDF2, described in section 5.2 of \cite{moriarty:2017:pkcs}. The fundamental idea behind it (which is shared among a few other early password hashing schemes) is to apply a \emph{pseudo-random function} a number of times, treating it as a parameter for computational cost.

One of the early kinds of attacks against password hashes are \emph{rainbow tables}. They are a classic example of a \emph{Time/Memory Tradeoff Attack} (TMTO). Given a dictionary of possible passwords (up to a certain length and using a particular set of symbols) and a hashing algorithm an attacker precomputes hash values well in advance. When a password database of the defender is leaked, the hash values are compared to those from the rainbow table and in case of a match the password can be recovered because the computation has already been performed.

The currently well-known practice to combat the rainbow table attack is to use a sufficiently large \emph{salt} when computing the password. This salt is a randomly generated value which is unique for every password and is openly stored alongside it in the defender's database. This ensures that the attacker will have to perform the computation after the leak (possibly giving a chance to the defender to change their password). Another nice property is that the same password used by several users will be very likely to produce distinct hash values.

These days an attacker can often compute a large number of hashes in parallel. If so, the increased individual computational time cost of one hash does not prevent the attacker from trying many combinations at once. The throughtput of the attack (average attempted passwords per second) remains high. This is the type of attacks addressed by memory-hard password hashign schemes. The main idea is that parallel systems (such as general-purpose GPUs or specialized ASICs and FPGAs) usually have significantly less memory per one processing unit. Therefore, if a password hashing process offers a memory cost parameter, an attacker will face greater costs per one parallel computation.

Arguably the first password hashing scheme to implement this idea this was scrypt, which was recently published as RFC 7914 \cite{percival:2016:scrypt}. However, this scheme is sometimes criticized for being overly complicated and not offering a decoupled way to control time and memory costs. In other words, there is a single parameter that controls both those values.

In order to create new designs which would address this problem, the Password Hashing Competition was announced in 2013 and concluded in 2015 \cite{wetzels:2016:phc}. Below follows a quick summary of its winner (Argon2) and all of the finalists except Lyra2. The latter is the main focus of this work and will be described in more detail later in \ref{chapter:lyra2}.

\section{Main Features of Catena}

\textsc{Catena} is a password-scrambling framework based on bit-reversal graphs. It packs such features as \emph{client-independent updates} which allows a hash value to be updated using larger time or memory cost parameters without the need to wait for a user to login. \textsc{Catena} also offers a \emph{server-relief} feature which allows to offload most of the hash computation to the client machine rather than the server, hence increasing the number of possible concurrent logins.

The \textsc{Catena-Butterfly(-Full)} and \textsc{Catena-Dragonfly(-Full)} are the most notable configurations of \textsc{Catena}. The former one is recommended when the memory-hard property is required. The \textsc{-Full} versions utilize the complete set of rounds of the underlying hash function Blake2b.

\section{Main Features of Makwa}

The core of Makwa is a "sequence of squarings of a composite (Blum) integer" \cite{pornin:2015:makwa}. A Blum integer is a natural integer \(n\) which can be represented as a \(pq\) where \(p\) and \(q\) are prime numbers with an additional property of:

\begin{IEEEeqnarray}{rCl}
    p &=& 3 \texttt{ mod } 4 \\
    q &=& 3 \texttt{ mod } 4
\end{IEEEeqnarray}

The squaring is primarily computation intensive and does not require a significant amount of memory. The \(p\) and \(q\) integers should be kept secret, if they are known then the computation can be accelerated considerably and provide the \emph{escrow} feature.

Makwa supports \emph{delegation} which is described as the ability to offload part of the computation to an untrusted third party. As well as that, \emph{client-independent updates} can also be made available.

\section{Main Features of yescrypt}

\emph{yescrypt} \cite{peslyak:2015:yescrypt} improves upon its predecessor, \emph{scrypt} \cite{percival:2016:scrypt}. However, yescrypt author Alexander Peslyak makes it clear that the author of scrypt is a different person, namely Colin Percival. The yescrypt PHS deals with some minor inconsistencies discovered in the specification of its predecessor. This is provided as a compatibility mode.

The yescrypt PHS also introduces a novel configuration with a read-only memory (ROM) table. In that configuration random lookups are performed so as to ensure that this table must remain in memory. Finally, the \texttt{YESCRYPT\_RW} flag enables these lookups as well as a number of optimized instructions.

\section{Main Features of Argon2}

\emph{Argon2} has two distinct configurations: \emph{Argon2i} and \emph{Argon2d}. The former revists the blocks of the in-memory matrix in the data-\emph{independent} fashion while the latter does so in a data-\emph{dependent} manner. This means that Argon2i is better suited for scenarios when \emph{side-channel attacks} are a viable concern, such as during password hashing or key derivation. At the same time Argon2d is more resistant to \emph{time-memory tradeoffs} which makes it more suitable for digital cryptocurrencies or other cases where proof-of-work is important.

Argon2 accepts the following set of parameters: password, salt, degree of paralelism, length of the produced hash (called a \emph{tag} in \cite{biryukov:2015:argon2}), memory cost, time cost, version number (for compatibility reasons, currently at \texttt{0x13}), secret value, associated data and type of configuration to use (Argon2i or Argon2d).

The more interesting parameters are the degree of parallelism as well as secret value together with associated data. The last of these three adds more flexibility to the scheme. The secret value parameter enables \emph{keyed-hashing} and improves security in case of a database leak. The degree of parallelism directly corresponds to the number of rows of the in-memory matrix.
