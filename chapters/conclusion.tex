%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
\label{sec:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The reference implementation of Lyra2 was successfully ported from C99 to Java 1.8. The resulting implementations produce identical hash values. In order to achieve that, several compatibility issues had to be addressed. In particular, adjusting for the mismatching endianness has to be constantly applied throughout all the stages of the algorithm.

The extra byte rotations require additional processing time. They cannot be avoided by design but can sometimes be performed simultaneously during other operations. In particular, the Blake2b and BlaMka sponge classes were adjusted to use both left and right rotations. This allowed to cut three quarters of the extra operations. Other compatibility issues included the need for pointer arithmetic simulation as well as 64-bit unsigned division.

The performance comparison of the two projects showed that the reference C implementation in general performs faster and requires less memory than its Java counterpart. This could be explained by the extra steps which the Java version has to take in order to produce compatible hash values. As well as that programming skill and language features could have played a part.

The mobile application was presented as the proof of concept for Lyra2 integration. It showed that lyra2-java can be included into an Android application just like any other Java library. Compared to the C reference implementation this might be easier for the developer. In turn, the saved developer time may be worth the drop in performance.

Finally, there are several viable options for further research. Firstly, algorithm-level compatibility can be sacrificed in favor of performance. However, personally I believe that producing the same hash values is key for successful adoption. Secondly, the parallel version of Lyra2 could be ported into Java. This would introduce another interesting layer for compatibility questions: concurrency. Finally, an exhaustive optimization effort of the Java implementation could be attempted as well. Although one significant optimization trick was pointed out in this work, there are likely to be more.
