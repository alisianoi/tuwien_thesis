%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{sec:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Passwords are currently the backbone of user authentication. Usually, passwords are stored in a hashed form in some kind of a database. Inevitably these databases are compromised and then the only thing which then stands between the attacker and the password cleartext is the hashing mechanism used to produce the hash value.

%=======================================================================
\section{Problem Description}
%=======================================================================
Processing power increases with time while simultaneously getting cheaper. This works both for the legitimate users as well as the attackers. Password Hashing Schemes (PHSs) are therefore continuously adjusted to stay irreversible. However, recent advances in highly parallelized hardware (conventional multicore GPUs as well as the more specialized FPGAs and ASICs) present a new challenge for the commonly used cryptographic hash functions: a large amount of simultaneous hash computation attempts can be performed in the time it takes a legitimate user to compute just one.

This is one of the reasons why a Password Hashing Competition was announced in 2013 and concluded in 2015. Its evaluation criteria stress that proposed candidates should provide minimal speed-up for the highly parallelized hardware. The winner was declared to be Argon2 and special recognition was also given to Catena \cite{forler:2013:catena}, Lyra2 \cite{andrade:2016:lyra2,marcos:2015:lyra2}, Makwa \cite{pornin:2015:makwa} and yescrypt \cite{peslyak:2015:yescrypt}.

%=======================================================================
\section{Motivation}
%=======================================================================
Even though the theoretical designs and their proof-of-concept implementations were presented back in 2015, the adoption of these new cryptographic algorithms could be improved. There are many ways to do so: provide better documentation, detailed usage examples and success stories. Porting reference implementations to different programming languages could also help programmers adopt these new cryptograhic algorithms.

%=======================================================================
\section{Contribution}
%=======================================================================
This work describes the porting process of the Lyra2 reference implementation into Java. The resulting implementation is hosted on the Maven central repository and is available for easy inclusion as a dependency into any Java project. It is licensed under the MIT license which is a well-established permissive free software license. Finally, the source code is publicly available and can be inspected and improved if necessary.

The primary goal of this porting effort is to provide a drop-in replacement for the reference implementation. This means that given the same input parameters, both implementations should produce the same hash values. Although this might sound as a natural and automatic requirement, the paper will highlight the discrepancies between the C and Java ecosystems.

The secondary goal is to compare the ported implementation to the original. The comparison project is done in the spirit of reproducible research, is hosted publicly and can be used to verify results presented in this paper.

The final goal is to use the ported implementation to write an Android application. This will demonstrate the ease of adoption of Lyra2 on a platform where using the reference implementation is much less straightforward.

%=======================================================================
\section{Outline of the Work}
%=======================================================================

% \begin{itemize}
%   \item Cover page
%   \item Acknowledgements
%   \item Abstract of the thesis in English and German
%   \item Table of contents
%   \item Introduction
%   	\begin{itemize}
%   		\item motivation
%   		\item problem statement (which problem should be solved?)
%   		\item aim of the work
%   		\item methodological approach
%   		\item structure of the work
%   	\end{itemize}
%   \item State of the art / analysis of existing approaches
%   	\begin{itemize}
%   		\item literature studies
%   		\item analysis
%   		\item comparison and summary of existing approaches
%   	\end{itemize}
%   \item Methodology
%   	\begin{itemize}
%   		\item used concepts
%   		\item methods and/or models
%   		\item languages
%   		\item design methods
%   		\item data models
%   		\item analysis methods
%   		\item formalisms
%   	\end{itemize}
%   \item Suggested solution/implementation
%   \item Critical reflection
%   	\begin{itemize}
%   		\item comparison with related work
%   		\item discussion of open issues
%   	\end{itemize}
%   \item Summary and future work
%   \item Appendix: source code, data models, \dots
%   \item Bibliography
% \end{itemize}
%
