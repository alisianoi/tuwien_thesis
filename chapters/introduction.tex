%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{sec:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Passwords are currently the backbone of user authentication. Usually, passwords are stored in a hashed form in some kind of a database. Such databases are fairly often compromised and then the hashing mechanism is what stands between the attacker and the password cleartext.

%=======================================================================
\section{Problem Description}
%=======================================================================
Processing power increases with time while simultaneously getting cheaper. This works both for the legitimate users as well as the attackers. Password Hashing Schemes (PHSs) are therefore continuously adjusted to stay irreversible. However, recent advances in highly parallelized hardware (conventional multicore GPUs as well as the more specialized FPGAs and ASICs) present a new challenge for the commonly used cryptographic hash functions. An attacker can heavily parallelize the computation, trying several thousands of password and salt combination in the time it takes a legitimate user to compute just one.

In order to limit the throughput a potential attacker could achieve, the Password Hashing Competition was announced in 2013 and concluded in 2015 \cite{wetzels:2016:phc}. Its evaluation criteria stress that proposed candidates should provide minimal speed-up for the highly parallelized hardware. The winner was declared to be Argon2 \cite{biryukov:2015:argon2} and special recognition was also given to Catena \cite{forler:2013:catena}, Lyra2 \cite{andrade:2016:lyra2,marcos:2015:lyra2}, Makwa \cite{pornin:2015:makwa} and yescrypt \cite{peslyak:2015:yescrypt}.

%=======================================================================
\section{Motivation}
%=======================================================================
Even though the theoretical designs and their proof-of-concept implementations were presented back in 2015, the adoption of these new cryptographic algorithms could be better. There are many ways to do so: provide better documentation, detailed usage examples and success stories. Porting an existing implementation into another programming language can also result in an adoption boost.

%=======================================================================
\section{Contribution}
%=======================================================================
This work describes the porting process of the Lyra2 reference implementation into Java. The resulting implementation is hosted in the Maven Central repository \cite{maven:2017:lyra2} as well as on GitHub \cite{github:2017:lyra2-java}. This makes it available for seamless inclusion as a dependency into any Java project. It is licensed under the MIT license which is a well-known permissive software license. Finally, the source code is publicly available and can be inspected or improved if necessary.

The primary goal of this porting effort is to provide a drop-in replacement for the reference implementation. Given the same input parameters, both implementations should produce the same hash values. Although this might sound like an automatic requirement, it is not in fact the case. The paper will highlight the challenges in details about the Java implementation section \ref{sec:java-implementation}.

The secondary goal is to compare the ported implementation to the original. The comparison project is done in the spirit of reproducible research, is hosted publicly on GitHub \cite{github:2017:lyra2-compare} and can be used to verify the results presented in this paper.

The final goal is to use the ported implementation to write an Android application. Section \ref{sec:mobile-application} demonstrates the ease of deployment of Lyra2 on a platform where using the reference implementation is not as straightforward.

%=======================================================================
\section{Outline of the Work}
%=======================================================================

\emph{Chapter \ref{chapter:related-work}} is devoted to an overview of related work. It opens with the discussion of secure authentication methods in section \ref{sec:secure-authentication} and secure communication in section \ref{sec:secure-communication}. Next, section \ref{sec:secure-password-storage} covers the issue of secure password storage and password hashing. It opens with the history of cryptographic competitions in subsection \ref{sec:cryptocomps}. A description of password hashing fundamentals follows in subsection \ref{sec:fundamentals}. Finally, subsections \ref{sec:makwa}, \ref{sec:catena}, \ref{sec:yescrypt} and \ref{sec:argon2} provide on overview of Password Hashing Competition finalists Makwa, Catena, yescrypt and Argon2.

\emph{Chapter \ref{sec:implementation-details}} covers Lyra2. It begins with the necessary theoretical information about the sponge and the duplex constructions in \ref{sec:lyra2-brief-description}. The different phases that Lyra2 iterates through when performing a hash computation are described there as well. Section \ref{sec:reference-implementation} outlines the build system and the various possible configurations of Lyra2. The section concludes with an extension of the build system which allows to compile several configurations at once as well as compute a bulk of hash values. The lyra2-java project is discussed next in \ref{sec:java-implementation}. It first deals with the transition from a function-based to an object-oriented project. The most important classes are shown in the UML diagram, see figure \ref{fig:uml}. Several classes which circumvent specific porting challenges are described. In particular, the endianness issue is shown in figure \ref{fig:little-endian} and a rotation trick for the Blake2b-based sponges is shown in figure \ref{fig:sponge-blake2b}.

\emph{Chapter \ref{sec:unit-testing-framework-choice}} discusses the choice of a unit testing framework. In particular, section \ref{sec:unit-boost-google} describes the effort it would take to set up \texttt{Boost.Test} for the reference projects Lyra2 and Argon2, showing possible reasons why those projects use their own solutions instead. Section \ref{sec:unit-junit-testng} motivates the choice of \texttt{JUnit} as a unit testing framework for lyra2-java. That section highlights the usefulness of parametrized testing. Finally, section \ref{sec:unit-pytest} provides reasons why the \texttt{harness} Python build scripts rely on the \texttt{py.test} framework to run parametrized tests as well.

\emph{Chpater \ref{sec:results}} summarizes the results. It begins with the demonstration that both projects produce the same hash values given the same inputs, see section \ref{sec:it-works}. First, a manual testing session is recorded in subsection \ref{sec:manual-testing}. Automated unit testing and continuous integration follow in subsection \ref{sec:automated-testing}. Then the performance comparison is presented in section \ref{sec:performance-comparison}. Due to a large number of configurable parameters in Lyra2, the first comparisons fix time- and memory costs (respectively, subsections \ref{sec:fixed-time-cost} and \ref{sec:fixed-memory-cost}). Section \ref{sec:no-fixed-costs} then deals with both changing time- and memory costs, resulting in several thousands of measurements displayed. A comparison conclusion follows in subsection \ref{sec:comparison-conclusion}. Section \ref{sec:mobile-application} presents the Android mobile application. It opens with the discussion of required Android API versions and tools. Then it shows several screenshots of the application which runs Lyra2.

\emph{Chapter \ref{sec:conclusion}} is the conclusion. It densely summarizes the results and suggests ideas for future research and development.
