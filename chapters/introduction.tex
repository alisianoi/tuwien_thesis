%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{sec:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Passwords are currently the backbone of user authentication. Usually, passwords are stored in a hashed form in some kind of a database. Such databases are fairly often compromised and then the hashing mechanism is what stands between the attacker and the password cleartext.

%=======================================================================
\section{Problem Description}
%=======================================================================
Processing power increases with time while simultaneously getting cheaper. This works both for the legitimate users as well as the attackers. Password Hashing Schemes (PHSs) are therefore continuously adjusted to stay irreversible. However, recent advances in highly parallelized hardware (conventional multicore GPUs as well as the more specialized FPGAs and ASICs) present a new challenge for the commonly used cryptographic hash functions. An attacker can heavily parallelize the computation, trying several thousands of password and salt combination in the time it takes a legitimate user to compute just one.

In order to limit the throutput a potential attacker could achieve, the Password Hashing Competition was announced in 2013 and concluded in 2015 \cite{wetzels:2016:phc}. Its evaluation criteria stress that proposed candidates should provide minimal speed-up for the highly parallelized hardware. The winner was declared to be Argon2 \cite{biryukov:2015:argon2} and special recognition was also given to Catena \cite{forler:2013:catena}, Lyra2 \cite{andrade:2016:lyra2,marcos:2015:lyra2}, Makwa \cite{pornin:2015:makwa} and yescrypt \cite{peslyak:2015:yescrypt}.

%=======================================================================
\section{Motivation}
%=======================================================================
Even though the theoretical designs and their proof-of-concept implementations were presented back in 2015, the adoption of these new cryptographic algorithms could be better. There are many ways to do so: provide better documentation, detailed usage examples and success stories. Porting an existing implementation into another programming language can also result in an adoption boost.

%=======================================================================
\section{Contribution}
%=======================================================================
This work describes the porting process of the Lyra2 reference implementation into Java. The resulting implementation is hosted in the Maven central repository \cite{maven:2017:lyra2} as well as on GitHub \cite{github:2017:lyra2-java}. This makes it available for seamless inclusion as a dependency into any Java project. It is licensed under the MIT license which is a well-known permissive software license. Finally, the source code is publicly available and can be inspected or improved if necessary.

The primary goal of this porting effort is to provide a drop-in replacement for the reference implementation. Given the same input parameters, both implementations should produce the same hash values. Although this might sound like an automatic requirement, it is not in fact the case. The paper will highlight the challenges in details about the Java implementation section \ref{sec:java-implementation}.

The secondary goal is to compare the ported implementation to the original. The comparison project is done in the spirit of reproducible research, is hosted publicly on GitHub \cite{github:2017:lyra2-compare} and can be used to verify the results presented in this paper.

The final goal is to use the ported implementation to write an Android application. Section \ref{sec:mobile-application} demonstrates the ease of deployment of Lyra2 on a platform where using the reference implementation is not as straightforward.

%=======================================================================
\section{Outline of the Work}
%=======================================================================

\emph{Section \ref{sec:fundamentals}} is devoted to theoretical background. It opens with the basic definitions as well as a brief mention of existing password hashing solutions which are either not memory-hard or have other notable drawbacks. A short description of Lyra2 follows in \ref{sec:lyra2-brief-description}, introducing the notion of a sponge function as well as a duplex construction. The main part of that section deals with the memory matrix created by Lyra2 and the way it interacts with the duplex constructions during the different phases of the algorithm.

\emph{Section \ref{sec:implementation-details}} covers implementation details. It begins with a quick discussion of the reference implementation \ref{sec:reference-implementation}. It outlines the build system and the various possible configurations of Lyra2. The section concludes with an extension of the build system which allows to compile several configurations at once as well as compute a bulk of hash values. The ported Lyra2 project is discussed next in \ref{sec:java-implementation}. It first deals with the transition from a function-based to an object-oriented project. The most important classes are shown on an UML diagram \ref{fig:uml}. Several classes exist to circumvent specific porting challenges. These challenges are explained and illustrated. In particular, the endianness issue is shown in figure \ref{fig:little-endian} and a rotation trick for the Blake2b-based sponge is shown in figure \ref{fig:sponge-blake2b}.

\emph{Section \ref{sec:results}} summarizes the results. It begins with the demonstration that both projects produce the same hash values given the same inputs \ref{sec:it-works}. First, a manual testing session is recorded in \ref{sec:manual-testing}. A section on continuous integration follows in \ref{sec:automated-testing}. Then the performance comparison is presented in section \ref{sec:performance-comparison}. Due to a large number of configurable parameters in Lyra2, the first comparisons fix time- and memory costs (respectively, subsections \ref{sec:fixed-time-cost} and \ref{sec:fixed-memory-cost}). Section \ref{sec:no-fixed-costs} then deals with both changing time- and memory costs, resulting in several thousands of measurements displayed. A comparison conclusion is made in \ref{sec:comparison-conclusion}. Finally, an Android mobile application is presented in \ref{sec:mobile-application}.
