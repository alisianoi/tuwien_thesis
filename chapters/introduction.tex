%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
\label{sec:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Passwords have been the backbone of user authentication for over 50 years, as stated by Bonneau et al. \cite{bonneau:2015:passwords-and-evolution-of-auth}. Using passwords securely has been shown to be difficult for both the end-users as well as developers. This fact has been demonstrated several times, see for instance Adams and Sasse \cite{adams:1999:users-are-not-the-enemy} or Green and Smith \cite{green:2016:developers-are-not-the-enemy}. This paper describes three stages during which password usage takes place in some form, namely \emph{authentication}, \emph{communication} and \emph{storage}. The description includes common practices as well as attack vectors.

Password security is crucial throughout all of these stages but the main focus of this work shifts specifically towards password storage. It is common practice to use some kind of a password database during this stage. For example, end-users these days have a choice of several password managers, some of which have been analyzed by Arias-Cabarcos et al. \cite{arias:2016:comparing}. Most of the time these databases use a password hashing technique so as to avoid storing passwords explicitly. If the password database is leaked then the strength of the password hashing algorithm is the last line of defense between the attacker and the user's password.

%=======================================================================
\section{Problem Description}
%=======================================================================
Processing power increases with time while simultaneously getting cheaper. This works both for the legitimate users as well as the attackers, so \glspl{phs} are continuously adjusted to stay irreversible. However, recent advances in highly parallelized hardware (conventional multicore \glspl{gpu} as well as the more specialized \glspl{fpga} and \glspl{asic}) present a new challenge for the commonly used cryptographic hash functions. An attacker can heavily parallelize the computation, trying several thousands of password and salt combination in the time it takes a legitimate user to compute just one.

In order to limit the throughput a potential attacker could achieve, new algorithm designs were required. Which is why the Password Hashing Competition was announced in 2013 and concluded in 2015, an overview could be found e.g. in Wetzels \cite{wetzels:2016:phc}. Its evaluation criteria stress that proposed candidates should provide minimal speed-up for the highly parallelized hardware. The winner was declared to be Argon2 by Biryukov et al. \cite{biryukov:2015:argon2} and special recognition was also given to Catena by Forler et al. \cite{forler:2013:catena}, Lyra2 by Andrade et al. \cite{andrade:2016:lyra2,marcos:2015:lyra2}, Makwa by Pornin et al. \cite{pornin:2015:makwa} and yescrypt by Peslyak \cite{peslyak:2015:yescrypt}.

%=======================================================================
\section{Motivation}
%=======================================================================
The theoretical designs and applied implementations for Argon \cite{biryukov:2015:argon2}, Catena \cite{forler:2013:catena}, Lyra2 \cite{andrade:2016:lyra2,marcos:2015:lyra2}, Makwa \cite{pornin:2015:makwa} and yescrypt \cite{peslyak:2015:yescrypt} existed back in 2015. However, the adoption of these new cryptographic algorithms could be better. There are many ways to achieve that: provide better documentation, detailed usage examples and success stories. Porting an existing implementation into another programming language can also result in an adoption boost.

%=======================================================================
\section{Contribution}
%=======================================================================
This work describes the porting process of the Lyra2 reference implementation into Java. The resulting implementation is hosted in the Maven Central repository \cite{maven:2017:lyra2} as well as on GitHub \cite{github:2017:lyra2-java}. This makes it available for seamless inclusion as a dependency into any Java project. It is licensed under the \gls{mit} License which is a well-known permissive software license. Finally, the source code is publicly available and can be inspected or improved if necessary.

The primary goal of this porting effort is to provide a drop-in replacement for the reference implementation. Given the same input parameters, both implementations should produce the same hash values. Although this might sound like an automatic requirement, it is not in fact the case. This paper will highlight the challenges and the necessary implementation details of the resulting Java project in Section \ref{sec:java-implementation}.

The secondary goal is to compare the ported implementation to the original. The comparison project is done in the spirit of reproducible research, is hosted publicly on GitHub \cite{github:2017:lyra2-compare} and can be used to verify the results presented in this paper.

The final goal is to use the ported implementation to write an Android application. Section \ref{sec:mobile-application} demonstrates the ease of deployment of Lyra2 on a platform where using the reference implementation is not as straightforward.

%=======================================================================
\section{Outline of the Work}
%=======================================================================

\emph{Chapter \ref{chapter:related-work}} is devoted to an overview of related work. It opens with the discussion of secure authentication methods in Section \ref{sec:secure-authentication} and secure communication in Section \ref{sec:secure-communication}. Next, Section \ref{sec:secure-password-storage} covers the issue of secure password storage and password hashing. It opens with the history of cryptographic competitions in Section \ref{sec:cryptocomps}. A description of password hashing fundamentals follows in Section \ref{sec:fundamentals}. Finally, Section \ref{sec:catena}, Section \ref{sec:makwa}, Section \ref{sec:yescrypt} and Section \ref{sec:argon2} provide an overview of Password Hashing Competition finalists Makwa, Catena, yescrypt and Argon2.

\emph{Chapter \ref{sec:implementation-details}} covers Lyra2. It begins with the necessary theoretical information about the sponge and the duplex constructions in Section \ref{sec:lyra2-brief-description}. The different phases that Lyra2 iterates through when performing a hash computation are described there as well. Section \ref{sec:reference-implementation} outlines the build system and the various possible configurations of Lyra2. The section concludes with an extension of the build system which allows to compile several configurations at once as well as compute a bulk of hash values. The \texttt{lyra2-java} project is discussed next in Section \ref{sec:java-implementation}. It first deals with the transition from a function-based to an object-oriented project. The most important classes are shown in the \gls{uml} diagram, see \autoref{fig:uml}. Several classes which circumvent specific porting challenges are described. In particular, the endianness issue is shown in \autoref{fig:little-endian} and a rotation trick for the Blake2b-based sponges is shown in \autoref{fig:sponge-blake2b} and \autoref{fig:sponge-blamka}.

\emph{Chapter \ref{sec:unit-testing-framework-choice}} discusses the choice of a unit testing framework. In particular, Section \ref{sec:unit-boost-google} describes the effort it would take to set up Boost.Test for the \texttt{lyra2-c} and Argon2 projects, showing possible reasons why those projects use their own solutions instead. Section \ref{sec:unit-junit-testng} motivates the choice of JUnit as a unit testing framework for the \texttt{lyra2-java} project. That section highlights the usefulness of parametrized testing. Finally, Section \ref{sec:unit-pytest} provides reasons why the \texttt{harness} Python build scripts rely on the py.test framework to run parametrized tests as well.

\emph{Chpater \ref{sec:results}} summarizes the results. It begins with the demonstration that both the \texttt{lyra2-c} and \texttt{lyra2-java} projects produce the same hash values given the same inputs, see Section \ref{sec:it-works}. First, a manual testing session is recorded in Section \ref{sec:manual-testing}. Automated unit testing and continuous integration follow in Section \ref{sec:automated-testing}. Then the performance comparison is presented in Section \ref{sec:performance-comparison}. Due to a large number of configurable parameters in Lyra2, the first comparisons fix time and memory costs (respectively, Section \ref{sec:fixed-time-cost} and Section \ref{sec:fixed-memory-cost}). Section \ref{sec:no-fixed-costs} then deals with both changing time and memory costs, resulting in several thousands of measurements displayed. A comparison conclusion follows in Section \ref{sec:comparison-conclusion}. Section \ref{sec:mobile-application} presents the Android mobile application. It opens with the discussion of required Android API versions and tools. Then it shows several screenshots of the application which runs Lyra2.

\emph{Chapter \ref{sec:conclusion}} is the conclusion. It densely summarizes the results and suggests ideas for future research and development.
