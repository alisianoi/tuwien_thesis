%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Theoretical Background}
\label{sec:fundamentals}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Password hashing} is the process of transforming a password into a hash value. Given the resulting hash value it should be computationally infeasible to restore the original password.

Password hashing is common practice when user authentication is required. The user provides a password which is then hashed using some password hashing algorithm and the result is compared against a hash value which was computed before with the correct password. If both hashes match, the user passes authentication.

When a password database is leaked, the password hashing process is what prevents the attackers from gaining the original plaintext passwords. One of the early password hashing schemes, which is widely used today, is PBKDF2, described in section 5.2 of \cite{moriarty:2017:pkcs}. The fundamental idea behind it (which is shared among a few other early password hashing schemes) is to apply a \emph{pseudo-random function} a number of times, treating it as a parameter for computational cost.

However, it is often the case that an attacker can to compute a large number of hashes in parallel. If so, the increased individual computational cost of one hash is not enough if a lot of such hashes are computed simultaneously. Parallel systems (such as general-purpose GPUs or specialized ASICs and FPGAs) usually have significantly less memory per one processing unit. Therefore, if a password hashing process offers a memory cost parameter, an attacker will face greater costs per one parallel computation.

Arguably the first password hashing scheme to address this was scrypt, which was recently published as as RFC 7914 \cite{percival:2016:scrypt}. However, this scheme is sometimes criticized for being overly complicated and not offering a decoupled way to control time and memory costs. In other words, there is a single parameter that controls both time and memory costs.

The password hashing competition was announced in 2013 and concluded in 2015 \cite{wetzels:2016:phc}. It was a call for better designs and Lyra2 is one of the finalists to receive special recognition.

%=======================================================================
\section{Lyra2: a Brief Description}
%=======================================================================

At the heart of Lyra2 is a \emph{sponge function} or a \emph{sponge construction} which is a class of algorithms with finite internal state that take an input bit stream of any length and produce an output bit stream of any desired length \cite{wiki:2017:sponge-function}. The internal state \(S\) consists of \(w = b + c\) bits, where \(w\) is known as the \emph{width} of the sponge, \(b\) is called its \emph{bitrate} and \(c\) its \emph{capacity}. At the heart of every sponge function lies a \emph{fixed-width permutation} \(f\) which takes \(w\) bits as input and produces \(w\) bits as output. A common example of \(f\) is Blake2b, which in its 64-bit modification operates on 128-byte chunks.

As shown in figure \ref{figure:sponge-construction}, a sponge function conceptually consists of two parts: the absorbing and the squeezing phase. To start with, an incoming message is padded so that its length is a multiple of \(b\) bits. Secondly, the internal state of the sponge is initialized with zeros. Then the absorbing phase begins: the next \(b\) bits of the message are XORed with the first \(b\) bits of \(S\) and then the \(f\) permutation is applied to the whole \(S\). This process repeats until the entire message has been absorbed. At this point the squeezing phase starts: the first \(b\) bits of \(S\) are emitted and then the \(f\) permutation is applied to the whole \(S\). This keeps going until the desired output length is reached.

\begin{figure}
  \begin{tikzpicture}[
  ostyle/.style={
      shape=rectangle
      ,draw
      ,minimum width=0.5cm,
    }
    ,fstyle/.style={
      shape=rectangle
      ,draw
      ,rounded corners=5pt
      ,minimum width=0.5cm
      ,minimum height=5cm
      }
    ,xstyle/.style={
    }
  ]

  \coordinate (A0) at (-0.5, 5) {};
  \coordinate (A1) at (-0.5, 3) {};
  \coordinate (A2) at (-0.5, 0) {};

  \draw [<->,semithick] (A0) to node [left] {\(b\)} (A1);
  \draw [<->,semithick] (A1) to node [left] {\(c\)} (A2);

  \node [ostyle,minimum height=2cm] (00) at (0.5, 4  ) {\(0\)};
  \node [ostyle,minimum height=3cm] (01) at (0.5, 1.5) {\(0\)};

  \node [shape=rectangle,draw] (padded message) at (-0.5, 6) {padded message};

  \coordinate (y0) at (1.5, 6) {};
  \coordinate (y1) at (3.5, 6) {};
  \coordinate (y2) at (5.5, 6) {};
  \coordinate (y3) at (7.5, 6) {};
  \coordinate (y4) at (9.5, 6) {};
  \draw [-] (padded message) to (y0) to (y1) to (y2);

  \node [xstyle] (x0) at (1.5, 4) {\(\oplus\)};
  \node [xstyle] (x1) at (3.5, 4) {\(\oplus\)};
  \node [xstyle] (x2) at (5.5, 4) {\(\oplus\)};
  \coordinate (x3) at (7.5, 4) {};
  \coordinate (x4) at (9.5, 4) {};

  \node [shape=rectangle] (absorb) at (3.5, -1) {absorbing phase};
  \node [shape=rectangle] (squeeze) at (9.5, -1) {squeezing phase};

  \draw [thick,dashed] (7.25, 6.5) -- (7.25, -1.5);

  \draw [->] (y0) to node [right,near start] {1\textsuperscript{st} \(b\) bits} (x0);
  \draw [->] (y1) to node [right,near start] {2\textsuperscript{nd} \(b\) bits} (x1);
  \draw [->] (y2) to node [right,near start] {3\textsuperscript{rd} \(b\) bits} (x2);
  \draw [->] (x3) to node [right,near end] {1\textsuperscript{st} \(b\) bits} (y3);
  \draw [->] (x4) to node [right,near end] {2\textsuperscript{nd} \(b\) bits} (y4);

  \node [fstyle] (f0) at ( 2.5, 2.5) {\(f\)};
  \node [fstyle] (f1) at ( 4.5, 2.5) {\(f\)};
  \node [fstyle] (f2) at ( 6.5, 2.5) {\(f\)};
  \node [fstyle] (f3) at ( 8.5, 2.5) {\(f\)};
  \node [fstyle] (f4) at (10.5, 2.5) {\(f\)};

  \draw [->] (00) to (x0);
  \draw [->] (x0) -- (x0 -| f0.west);
  \draw [->] ($(f0.east) + (0, 1.5)$) -- (x1);
  \draw [->] (x1) -- (x1 -| f1.west);
  \draw [->] ($(f1.east) + (0, 1.5)$) -- (x2);
  \draw [->] (x2) -- (x2 -| f2.west);
  \draw [-] ($(f2.east) + (0, 1.5)$) -- (x3);
  \draw [-] (x3) -- ($(f3.west) + (0, 1.5)$);
  \draw [-] ($(f3.east) + (0, 1.5)$) -- (x4);
  \draw [-] (x4) -- ($(f4.west) + (0, 1.5)$);
  \draw [->] ($(f4.east) + (0, 1.5)$) -- ($(f4.east) + (1, 1.5)$);

  \draw [->] (01) -- (01 -| f0.west);
  \draw [->] ($(f0.east) + (0, -1)$) -- ($(f1.west) + (0, -1)$);
  \draw [->] ($(f1.east) + (0, -1)$) -- ($(f2.west) + (0, -1)$);
  \draw [->] ($(f2.east) + (0, -1)$) -- ($(f3.west) + (0, -1)$);
  \draw [->] ($(f3.east) + (0, -1)$) -- ($(f4.west) + (0, -1)$);
  \draw [->] ($(f4.east) + (0, -1)$) -- ($(f4.east) + (1, -1)$);

  \end{tikzpicture}
  \caption{The sponge construction, adapted from \cite{bertoni:2011:duplexing,marcos:2015:lyra2}}
  \label{figure:sponge-construction}
\end{figure}

A similar cryptographic primitive is the \emph{duplex construction}. The main difference with the sponge construction is that both the absorbtion of incoming bits and the squeezing of the outgoing bits happens simultaneously, in a tick-tock fashion. The name is based on an analogy between the half- and full-duplex modes of communication. A formal description can be found in \cite{bertoni:2011:duplexing} and an explanatory figure is provided \ref{figure:duplex-construction}. An important detail is that \cite{bertoni:2011:duplexing} proves that the sponge and duplex constructions are equally secure.

\begin{figure}
  \begin{tikzpicture}[
  ostyle/.style={
      shape=rectangle
      ,draw
      ,minimum width=0.5cm,
    }
    ,fstyle/.style={
      shape=rectangle
      ,draw
      ,rounded corners=5pt
      ,minimum width=0.5cm
      ,minimum height=5cm
      }
    ,xstyle/.style={
    }
  ]

  \coordinate (A0) at (-0.5, 5) {};
  \coordinate (A1) at (-0.5, 3) {};
  \coordinate (A2) at (-0.5, 0) {};

  \draw [<->,semithick] (A0) to node [left] {\(b\)} (A1);
  \draw [<->,semithick] (A1) to node [left] {\(c\)} (A2);

  \node [ostyle,minimum height=2cm] (00) at (0.5, 4  ) {\(0\)};
  \node [ostyle,minimum height=3cm] (01) at (0.5, 1.5) {\(0\)};

  \coordinate (x00) at ( 1.5, 6) {};
  \coordinate (x01) at ( 4.5, 6) {};
  \coordinate (x02) at ( 7.5, 6) {};
  \coordinate (x03) at (10.5, 6) {};

  \node [xstyle] (x10) at ( 1.5, 4) {\(\oplus\)};
  \node [xstyle] (x11) at ( 4.5, 4) {\(\oplus\)};
  \node [xstyle] (x12) at ( 7.5, 4) {\(\oplus\)};
  \node [xstyle] (x13) at (10.5, 4) {\(\oplus\)};

  \draw [->] (x00) to node [anchor=south,rotate=90] {1\textsuperscript{st} \(b\) bits} (x10);
  \draw [->] (x01) to node [anchor=south,rotate=90] {2\textsuperscript{nd} \(b\) bits} (x11);
  \draw [->] (x02) to node [anchor=south,rotate=90] {3\textsuperscript{rd} \(b\) bits} (x12);
  \draw [->] (x03) to node [anchor=south,rotate=90] {4\textsuperscript{th} \(b\) bits} (x13);

  \coordinate (x14) at (13.5, 4) {};
  \coordinate (x24) at (13.5, 1.5) {};

  \coordinate (y00) at (3.5, 6) {};
  \coordinate (y01) at (6.5, 6) {};
  \coordinate (y02) at (9.5, 6) {};

  \coordinate (y10) at (3.5, 4) {};
  \coordinate (y11) at (6.5, 4) {};
  \coordinate (y12) at (9.5, 4) {};

  \draw [<-] (y00) to node [anchor=south,rotate=90] {1\textsuperscript{st} \(b\) bits} (y10);
  \draw [<-] (y01) to node [anchor=south,rotate=90] {2\textsuperscript{nd} \(b\) bits} (y11);
  \draw [<-] (y02) to node [anchor=south,rotate=90] {3\textsuperscript{rd} \(b\) bits} (y12);

  \draw [->] (y10) -- (y00);
  \draw [->] (y11) -- (y01);
  \draw [->] (y12) -- (y02);

  \node [fstyle] (f0) at ( 2.5, 2.5) {\(f\)};
  \node [fstyle] (f1) at ( 5.5, 2.5) {\(f\)};
  \node [fstyle] (f2) at ( 8.5, 2.5) {\(f\)};
  \node [fstyle,dashed] (f3) at (11.5, 2.5) {\(f\)};

  \draw [->] (00) to (x10);
  \draw [->] (x0) -- (x0 -| f0.west);
  \draw [->] ($(f0.east) + (0, 1.5)$) -- (x11);
  \draw [->] (y10) -- (y00);
  \draw [->] (x11) -- (x11 -| f1.west);
  \draw [->] ($(f1.east) + (0, 1.5)$) -- (x12);
  \draw [->] (x12) -- (x12 -| f2.west);
  \draw [->] ($(f2.east) + (0, 1.5)$) -- (x13);
  \draw [->] (x13) -- ($(f3.west) + (0, 1.5)$);
  \draw [->,dashed] ($(f3.east) + (0, 1.5)$) -- (x14);

  \draw [->] (01) -- (01 -| f0.west);
  \draw [->] ($(f0.east) + (0, -1)$) -- ($(f1.west) + (0, -1)$);
  \draw [->] ($(f1.east) + (0, -1)$) -- ($(f2.west) + (0, -1)$);
  \draw [->] ($(f2.east) + (0, -1)$) -- ($(f3.west) + (0, -1)$);
  \draw [->,dashed] ($(f3.east) + (0, -1)$) -- (x24);

  \end{tikzpicture}
  \caption{The duplex construction, adapted from \cite{bertoni:2011:duplexing,marcos:2015:lyra2}}
  \label{figure:duplex-construction}
\end{figure}

Another important component of Lyra2 design is the memory matrix. Its size is directly controlled by the memory cost parameter which corresponds to the number of rows of the matrix. An implementation detail are two other parameters: number of columns (switch \verb|--columns|) and block length (switch \verb|--blocks|). Their product equals the number of 64-bit words in a single row of the memory matrix. The reference C implementation sets both of these parameters at compile time while the Java implementation exposes them at runtime.

Conceptually, Lyra2 is a sequential application of a duplex construction which continuously reads and writes blocks to and from the memory matrix. The algorithm is structured into four main phases that take place one after the other: \emph{Bootstrapping}, \emph{Setup}, \emph{Wandering}, and \emph{Wrap-up}.

During the \emph{Bootstrapping} phase the main event is the initialization of the sponge. It absorbs the password together with the salt and a few other parameters such as: lengths of output, password and salt, time cost, memory cost and number of columns. If requried, this list could be expanded with application-specific information like user- or domain name.

The \emph{Setup} phase deals primarily with initializing the memory matrix. The sponge here is used as a duplex construction: it continuously writes to the uninitialized rows of the matrix as well as updates some of the already visited ones. It takes special care so as not to let potential attackers discard parts of the memory matrix as well as uses a reduced number of rounds of the permutation \(f\) which is powering the sponge. This phase ends once the last row of the matrix is visited for the first time.

The \emph{Wandering} phase is the main operation phase of the sponge. It continues for \(time\_cost \times memory\_cost\) iterations and is by far the longest phase. The fact that both the \(time\_cost\) and the \(memory\_cost\) are decoupled allows legitimate users to fine-tune the parameter values to take full advantage of their platform. During the wandering phase, the rows of the memory matrix are continuously revisited und updated in a randomized fashion which is determined by the input parameters. Attention is paid to not allow time-memory tradeoffs that would either a) allow to parallelize computations or b) allow to discard part of the memory matrix and recompute it later.

Finally, the \emph{Wrap-up} phase concludes with a full-round absorbing operation by the sponge (which ensures that Lyra2 is at least as secure as the sponge) and a full-round squeeze operation that produces the requested number of output bits.
